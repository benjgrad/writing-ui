'use client'

import { useState, useRef, useEffect, useCallback, useMemo } from 'react'
import { useKeyboardCapture } from '@/hooks/useKeyboardCapture'
import { useCharacterBuffer } from '@/hooks/useCharacterBuffer'
import { useWordFading } from '@/hooks/useWordFading'
import { useLineManager } from '@/hooks/useLineManager'
import { useScrollBehavior } from '@/hooks/useScrollBehavior'
import { useAutoSave } from '@/hooks/useAutoSave'
import { WritingLine } from './WritingLine'
import { HistoryView } from './HistoryView'
import { IdlePrompt } from './IdlePrompt'
import { EditorToolbar } from './EditorToolbar'
import type { Document, WordWithTimestamp } from '@/types/document'

interface DreamEditorProps {
  userId: string
  initialDocument?: Document | null
}

export function DreamEditor({ userId, initialDocument }: DreamEditorProps) {
  const [title, setTitle] = useState(initialDocument?.title || 'Untitled')
  const [showPrompt, setShowPrompt] = useState(true) // Show prompt on load
  const [aiPrompt, setAiPrompt] = useState<string | null>(null)
  const [isLoadingPrompt, setIsLoadingPrompt] = useState(false)
  const [lastTypedAt, setLastTypedAt] = useState(0) // Track last input for idle detection
  const [isAIGeneratingTitle, setIsAIGeneratingTitle] = useState(false)
  const [hasAutoGeneratedTitle, setHasAutoGeneratedTitle] = useState(false)

  const containerRef = useRef<HTMLDivElement>(null)
  const hiddenInputRef = useRef<HTMLTextAreaElement>(null)
  const promptFetchedRef = useRef(false)
  const [virtualInputValue, setVirtualInputValue] = useState('')
  const editorZoneTop = typeof window !== 'undefined' ? window.innerHeight * 0.3 : 300

  // Character/word/line state management
  const {
    lines,
    currentLineIndex,
    currentVisualRowId,
    addCharacter,
    addNewLine,
    deleteCharacter,
    startNewVisualRow,
    fullContent,
    allWords,
    recentCharIds,
    deletionBlocked,
    protectedWordIds,
  } = useCharacterBuffer()

  // Handle first word fading on current line - switch to new visual row
  const handleFirstWordFading = useCallback(
    (lineId: string) => {
      if (lineId === lines[currentLineIndex]?.id) {
        startNewVisualRow()
      }
    },
    [lines, currentLineIndex, startNewVisualRow]
  )

  // Word fading (30-second timers)
  const {
    isWordFading,
    isWordFaded,
    allFaded,
  } = useWordFading({
    words: allWords,
    enabled: true,
    lastTypedAt,
    onFirstWordFadingOnLine: handleFirstWordFading,
  })

  // Line positioning
  const { containerStyle, registerLineHeight } = useLineManager({
    lines,
    currentLineIndex,
    enabled: true,
  })

  // Handle auto-naming on first save
  const handleFirstSave = useCallback(async (_documentId: string, content: string) => {
    // Only auto-generate title if it's still "Untitled" and we haven't already
    if (title === 'Untitled' && !hasAutoGeneratedTitle && content.trim().length >= 10) {
      setHasAutoGeneratedTitle(true)
      setIsAIGeneratingTitle(true)

      try {
        const response = await fetch('/api/ai/generate-title', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ content }),
        })

        if (response.ok) {
          const data = await response.json()
          if (data.title) {
            setTitle(data.title)
          }
        }
      } catch (error) {
        console.error('Failed to auto-generate title:', error)
      } finally {
        setIsAIGeneratingTitle(false)
      }
    }
  }, [title, hasAutoGeneratedTitle])

  // Auto-save
  const {
    isSaving,
    lastSaved,
    error: saveError,
    debouncedSave,
  } = useAutoSave({
    documentId: initialDocument?.id || null,
    userId,
    onFirstSave: handleFirstSave,
  })

  // Get history content - combines initial document content with ALL content from current session
  // (both faded and non-faded words, so scrolling up shows everything)
  const historyContent = useMemo(() => {
    // Build content from all words (not just faded ones)
    const allContent = fullContent

    // Combine initial document content with current session content
    if (initialDocument?.content && allContent) {
      return initialDocument.content + allContent
    }
    if (initialDocument?.content) {
      return initialDocument.content
    }
    return allContent
  }, [fullContent, initialDocument?.content])

  // Track if we have history content
  const hasHistory = Boolean(historyContent || initialDocument?.content)

  // Scroll behavior for history
  const {
    promptOpacity,
    editorOpacity,
    historyOpacity,
    scrollToEditor,
    handleKeyboardInput,
    updateHistoryHeight,
    isInEditor,
  } = useScrollBehavior({
    containerRef,
    editorZoneTop,
    hasHistory,
    enabled: true,
  })

  // Handle character input
  const handleCharacter = useCallback(
    (char: string) => {
      // Dismiss prompt and scroll to editor if needed
      if (showPrompt) {
        setShowPrompt(false)
        promptFetchedRef.current = false
        setAiPrompt(null)
      }
      handleKeyboardInput()
      addCharacter(char)
      setLastTypedAt(Date.now()) // Track for idle detection
    },
    [showPrompt, handleKeyboardInput, addCharacter]
  )

  // Handle backspace
  const handleBackspace = useCallback(() => {
    if (showPrompt) {
      setShowPrompt(false)
    }
    handleKeyboardInput()
    deleteCharacter()
    setLastTypedAt(Date.now()) // Track for idle detection
  }, [showPrompt, handleKeyboardInput, deleteCharacter])

  // Handle enter
  const handleEnter = useCallback(() => {
    if (showPrompt) {
      setShowPrompt(false)
      promptFetchedRef.current = false
      setAiPrompt(null)
    }
    handleKeyboardInput()
    addNewLine()
    setLastTypedAt(Date.now()) // Track for idle detection
  }, [showPrompt, handleKeyboardInput, addNewLine])

  // Handle textarea input (for mobile keyboard support)
  const handleTextareaInput = useCallback((e: React.ChangeEvent<HTMLTextAreaElement>) => {
    const newValue = e.target.value
    const oldValue = virtualInputValue

    if (showPrompt) {
      setShowPrompt(false)
      promptFetchedRef.current = false
      setAiPrompt(null)
    }
    handleKeyboardInput()

    // Detect added or deleted characters
    if (newValue.length > oldValue.length) {
      const addedChars = newValue.slice(oldValue.length)
      for (const char of addedChars) {
        if (char === '\n') {
          addNewLine()
        } else {
          addCharacter(char)
        }
      }
    } else if (newValue.length < oldValue.length) {
      const deletedCount = oldValue.length - newValue.length
      for (let i = 0; i < deletedCount; i++) {
        deleteCharacter()
      }
    }

    setVirtualInputValue(newValue)
    setLastTypedAt(Date.now())
  }, [virtualInputValue, showPrompt, handleKeyboardInput, addCharacter, addNewLine, deleteCharacter])

  // Focus hidden input when editor is tapped (for mobile)
  const handleEditorTap = useCallback(() => {
    hiddenInputRef.current?.focus()
  }, [])

  // Auto-focus hidden input on mount for mobile
  useEffect(() => {
    const timer = setTimeout(() => {
      hiddenInputRef.current?.focus()
    }, 100)
    return () => clearTimeout(timer)
  }, [])

  // Keyboard capture
  useKeyboardCapture({
    onCharacter: handleCharacter,
    onBackspace: handleBackspace,
    onEnter: handleEnter,
    enabled: true,
  })

  // Re-show prompt when all text has faded
  useEffect(() => {
    const allWordsHaveFaded = allFaded && allWords.length > 0
    const isEmptyStart = allWords.length === 0 && lines.length === 1

    if ((allWordsHaveFaded || isEmptyStart) && !showPrompt) {
      setShowPrompt(true)
      promptFetchedRef.current = false // Allow fetching a new prompt
    }
  }, [allFaded, allWords.length, lines.length, showPrompt])

  // Fetch AI prompt when needed
  useEffect(() => {
    const shouldFetchPrompt =
      (allFaded && allWords.length > 0) || // All text faded
      (allWords.length === 0 && lines.length === 1) // Initial empty state

    if (shouldFetchPrompt && !promptFetchedRef.current && showPrompt) {
      promptFetchedRef.current = true
      setIsLoadingPrompt(true)

      const context = historyContent || initialDocument?.content || ''

      fetch('/api/ai/prompt', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ context }),
      })
        .then((res) => res.json())
        .then((data) => {
          setAiPrompt(data.prompt)
        })
        .catch(() => {
          setAiPrompt('What would you like to write about?')
        })
        .finally(() => {
          setIsLoadingPrompt(false)
        })
    }
  }, [allFaded, allWords.length, lines.length, showPrompt, historyContent, initialDocument?.content])

  // Auto-save when content changes
  useEffect(() => {
    if (fullContent.trim()) {
      // Prepend initial document content to preserve existing text
      const contentToSave = initialDocument?.content
        ? initialDocument.content + fullContent
        : fullContent

      const words: WordWithTimestamp[] = allWords.map((w) => ({
        id: w.id,
        word: w.characters.map((c) => c.char).join(''),
        typedAt: w.startedAt,
      }))

      debouncedSave(contentToSave, words, title)
    }
  }, [fullContent, allWords, title, debouncedSave, initialDocument?.content])

  // Handle title changes - also trigger save immediately
  const handleTitleChange = useCallback(
    (newTitle: string) => {
      setTitle(newTitle)
      // Trigger an immediate save for the title change
      const contentToSave = initialDocument?.content
        ? initialDocument.content + fullContent
        : fullContent || ''
      const words: WordWithTimestamp[] = allWords.map((w) => ({
        id: w.id,
        word: w.characters.map((c) => c.char).join(''),
        typedAt: w.startedAt,
      }))
      debouncedSave(contentToSave, words, newTitle)
    },
    [initialDocument?.content, fullContent, allWords, debouncedSave]
  )

  // Handle AI title generation request
  const handleRequestAIRename = useCallback(async () => {
    const content = historyContent || fullContent
    if (!content || content.trim().length < 10) {
      return // Not enough content to generate title
    }

    setIsAIGeneratingTitle(true)
    try {
      const response = await fetch('/api/ai/generate-title', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ content }),
      })

      if (response.ok) {
        const data = await response.json()
        if (data.title) {
          setTitle(data.title)
          // Also trigger save with new title
          const contentToSave = initialDocument?.content
            ? initialDocument.content + fullContent
            : fullContent || ''
          const words: WordWithTimestamp[] = allWords.map((w) => ({
            id: w.id,
            word: w.characters.map((c) => c.char).join(''),
            typedAt: w.startedAt,
          }))
          debouncedSave(contentToSave, words, data.title)
        }
      }
    } catch (error) {
      console.error('Failed to generate title:', error)
    } finally {
      setIsAIGeneratingTitle(false)
    }
  }, [historyContent, fullContent, initialDocument?.content, allWords, debouncedSave])

  // Word count
  const wordCount = useMemo(() => {
    return fullContent.split(/\s+/).filter(Boolean).length
  }, [fullContent])

  return (
    <div className="dream-gradient min-h-screen relative">
      <EditorToolbar
        title={title}
        onTitleChange={handleTitleChange}
        onRequestAIRename={handleRequestAIRename}
        isAIGenerating={isAIGeneratingTitle}
        isSaving={isSaving}
        lastSaved={lastSaved}
        wordCount={wordCount}
        error={saveError}
      />

      {/* Hidden textarea for mobile keyboard - positioned off-screen */}
      <textarea
        ref={hiddenInputRef}
        value={virtualInputValue}
        onChange={handleTextareaInput}
        style={{
          position: 'fixed',
          top: '-9999px',
          left: '-9999px',
          opacity: 0,
          fontSize: '16px',
        }}
        autoCapitalize="off"
        autoCorrect="off"
        autoComplete="off"
        spellCheck={false}
      />

      {/* Main scroll container */}
      <div
        ref={containerRef}
        className="dream-scroll-container min-h-screen pt-14"
        style={{
          height: '100vh',
          overflowY: 'auto',
        }}
      >
        {/* History zone (above editor) */}
        {historyContent && (
          <HistoryView
            content={historyContent}
            opacity={historyOpacity}
            onHeightChange={updateHistoryHeight}
          />
        )}

        {/* Editor zone */}
        <div
          className="editor-fade-on-scroll"
          onClick={handleEditorTap}
          style={{
            display: 'flex',
            flexDirection: 'column',
            justifyContent: 'center',
            alignItems: 'center',
            paddingTop: historyContent ? '2rem' : '30vh',
            paddingBottom: '30vh',
            paddingLeft: '1rem',
            paddingRight: '1rem',
            opacity: editorOpacity,
            minHeight: '100vh',
          }}
        >
          {/* Lines container with scroll offset */}
          <div
            className="w-full max-w-[700px] line-scrolling"
            style={containerStyle}
          >
            {lines.map((line, lineIndex) => (
              <WritingLine
                key={line.id}
                line={line}
                isCurrentLine={lineIndex === currentLineIndex}
                currentVisualRowId={currentVisualRowId}
                isWordFading={isWordFading}
                isWordFaded={isWordFaded}
                recentCharIds={recentCharIds}
                deletionBlocked={deletionBlocked}
                protectedWordIds={protectedWordIds}
                onHeightChange={registerLineHeight}
              />
            ))}
          </div>
        </div>

        {/* Spacer to allow scrolling past the last line */}
        <div style={{ height: '50vh' }} />
      </div>

      {/* AI prompt overlay */}
      {showPrompt && isInEditor && (
        <IdlePrompt
          prompt={aiPrompt}
          isLoading={isLoadingPrompt}
          opacity={promptOpacity}
          onDismiss={() => setShowPrompt(false)}
        />
      )}
    </div>
  )
}
